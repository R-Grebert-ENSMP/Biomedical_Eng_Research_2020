import math as m 
import numpy as np
from numba import vectorize

###########UNITES###########
#pression : Pa
#volume : m^3
#debit : m^3/s
#longueur : m 
#temps : s
############################

###########VARIABLES########


####SANE INDIVIDUAL DATA####

#Résistance des tissus respiratoires (Pa.m^-3.s)
R=0.028*1e+06
#Résistance à l'écoulement de l'air dans les voies supérieures
R_ext = 1.2e7   #Pa.(m^3.s^-1)^-1.68
r = 1.68
#Choix de la pression motrice initiale
Pm=24000
#Choix de la constante de temps de relaxation des muscles expiratoires
tau=0.2
#Volume résiduel (volume d'air min dans les poumons)
RV=1.5e-3
#Capacité vitale (Volume d'air max dans les poumons)
CV=5.5e-3
# Diamètre de la trachée et dimension fractale
Dmax_0 = 2e-2
h_list = [[1,0.87,0.80,0.83,0.86]+[0.85 for k in range(15)],[1,0.69,0.67,0.67,0.74]+[0.67 for k in range(15)]]
L_list = [3,3.07,1.75,1.43,1.85]+[3 for k in range(15)]
# Compliance pulmonaire à P de rétraction élastique nulle:
C_0 = 5.7e-6 #m^3.Pa-1
# Volumes pulmonaires min et max, = à 106 et 20% de la CPT (Capacité Pulmonaire Totale  = CV+RV)
V_max = 7.5e-3 #m^3
V_min = 1.4e-3 #m^3

Compliance_param  = [ [0,0.882,0.0108e-2,1,10],
                    [1,0.882,0.0294e-2,1,10],
                    [2,0.686,0.050e-2,1,10],
                    [3,0.546,0.078e-2,1,10],
                    [4,0.428,0.098e-2,1,10],
                    [5,0.337,0.123e-2,1,10],
                    [6,0.265,0.139e-2,1,10],
                    [7,0.208,0.156e-2,1,10],
                    [8,0.164,0.171e-2,1,10],
                    [9,0.129,0.180e-2,1,10],
                    [10,0.102,0.190e-2,1,10],
                    [11,0.080,0.202e-2,1,9],
                    [12,0.063,0.214e-2,1,8],
                    [13,0.049,0.221e-2,1,8],
                    [14,0.039,0.228e-2,1,8],
                    [15,0.031,0.234e-2,1,7] ]

# ####SEVERE COPD INDIVIDUAL DATA####

# # Diamètre de la trachée et dimension fractale
# Dmax_0 = 2e-2
# h_list = [1]+[0.68,0.7,0.75,0.8]+[0.85 for k in range(20)] #+[2**(-1/3) for k in range(20)] +
# h_th = 2**(-1/3)

# #Résistance des tissus respiratoires (Pa.m^-3.s)
# R=0.050*1e+06
# #Résistance à l'écoulement de l'air dans les voies supérieures
# R_ext = 1.2e7   #Pa.(m^3.s^-1)^-1.68
# r = 1.68
# #Choix de la pression motrice initiale
# Pm=24000
# #Choix de la constante de temps de relaxation des muscles expiratoires
# tau=0.2

# #Severity of COPD (0 = mild, 1 = severe)
# #COPD_lvl = 0
# #Volume résiduel (volume d'air min dans les poumons)
# RV= (2.5 + 1.5*COPD_lvl)e-3
# #Capacité vitale (Volume d'air max dans les poumons)
# CV= (5.5-0.5*COPD_lvl)e-3

# # Compliance pulmonaire à P de rétraction élastique nulle:
# C_0 = (8.55+3.85*COPD_lvl)e-6 #m^3.Pa-1
# # Volumes pulmonaires min et max. CPT(Capacité Pulmonaire Totale  = CV+RV)
# V_max = (8.5+COPD_lvl)e-3 #m^3
# V_min = (2+1.5*COPD_lvl)e-3 #m^3

# Compliance_param  = [ [0,0.78-0.22*COPD_lvl,0.01e-2,1,10],
#                         [1,0.78-0.34*COPD_lvl,0.02e-2,1,10],
#                         [2,0.54-0.22*COPD_lvl,0.03e-2,1,10],
#                         [3,0.38-0.18*COPD_lvl,(0.04-0.004*COPD_lvl)*1e-2,1,10],
#                         [4,0.28-0.13*COPD_lvl,(0.05-0.014*COPD_lvl)*1e-2,1,10],
#                         [5,0.2-0.07*COPD_lvl,(0.062-0.028*COPD_lvl)*1e-2,1,10],
#                         [6,0.13-0.03*COPD_lvl,(0.07-0.04*COPD_lvl)*1e-2,1,10],
#                         [7,0.10-0.03*COPD_lvl,(0.071-0.04*COPD_lvl)*1e-2,1,10],
#                         [8,0.052-0.01*COPD_lvl,(0.072-0.043*COPD_lvl)*1e-2,1,10],
#                         [9,0.048-0.01*COPD_lvl,(0.073-0.046*COPD_lvl)*1e-2,1,10],
#                         [10,0.042-0.01*COPD_lvl,(0.074-0.05*COPD_lvl)*1e-2,1,10],
#                         [11,0.038-0.01*COPD_lvl,(0.075-0.052*COPD_lvl)*1e-2,1,9],
#                         [12,0.033-0.01*COPD_lvl,(0.076-0.053*COPD_lvl)*1e-2,1,8],
#                         [13,0.028-0.01*COPD_lvl,(0.077-0.053*COPD_lvl)*1e-2,1,8],
#                         [14,0.020-0.005*COPD_lvl,(0.078-0.053*COPD_lvl)*1e-2,1,8],
#                         [15,0.015-0.005*COPD_lvl,(0.079-0.053*COPD_lvl)*1e-2,1,7] ]

# #### LUNG FIBROSIS DATA####

# # Diamètre de la trachée et dimension fractale
# Dmax_0 = 2e-2
# h_list = [1]+[0.68,0.7,0.75,0.8]+[0.85 for k in range(20)] #+[2**(-1/3) for k in range(20)] +
# h_th = 2**(-1/3)

# #Severity of Fibrosis (0 = mild, 1 = severe)
# FIB_lvl = 0

# #Résistance des tissus respiratoires (Pa.m^-3.s)
# R=(0.1+0.1*FIB_lvl)*1e+06
# #Résistance à l'écoulement de l'air dans les voies supérieures
# R_ext = 1.2e7   #Pa.(m^3.s^-1)^-1.68
# r = 1.68
# #Choix de la pression motrice initiale
# Pm=24000
# #Choix de la constante de temps de relaxation des muscles expiratoires
# tau=0.2


# #Volume résiduel (volume d'air min dans les poumons)
# RV= (1.2 - 0.2*FIB_lvl)e-3
# #Capacité vitale (Volume d'air max dans les poumons)
# CV= (4.4-1.1*FIB_lvl)e-3

# # Compliance pulmonaire à P de rétraction élastique nulle:
# C_0 = (4.3-1.6*FIB_lvl)e-6 #m^3.Pa-1
# # Volumes pulmonaires min et max. CPT(Capacité Pulmonaire Totale  = CV+RV)
# V_max = (5.65-1.3*FIB_lvl)e-3 #m^3
# V_min = (1.19-0.19*FIB_lvl)e-3 #m^3

# Compliance_param  = [ [0,0.9,0.01e-2,1,10],
#                     [1,0.9,0.02e-2,1,10],
#                     [2,0.73+0.08*FIB_lvl,(0.04-0.01*FIB_lvl)*1e-2,1,10],
#                     [3,0.57+0.12*FIB_lvl,(0.068-0.018*FIB_lvl)*1e-2,1,10],
#                     [4,0.45+0.08*FIB_lvl,(0.098-0.018*FIB_lvl)*1e-2,1,10],
#                     [5,0.36+0.12*FIB_lvl,(0.133-0.033*FIB_lvl)*1e-2,1,10],
#                     [6,0.29+0.07*FIB_lvl,(0.149-0.03*FIB_lvl)*1e-2,1,10],
#                     [7,0.23+0.08*FIB_lvl,(0.166-0.033*FIB_lvl)*1e-2,1,10],
#                     [8,0.18+0.08*FIB_lvl,(0.181-0.035*FIB_lvl)*1e-2,1,10],
#                     [9,0.15+0.08*FIB_lvl,(0.190-0.034*FIB_lvl)*1e-2,1,10],
#                     [10,0.12+0.08*FIB_lvl,(0.2-0.034*FIB_lvl)*1e-2,1,10],
#                    ]



#################################################################################
eta=1.8e-05          #Viscosité de l'air (Pa.s)
rho=1.14             #Masse volumique de l'air (kg/m^3)
P_atm = 0.0# 1013e2       #Atmospheric pressure
##################################################################################

import time  
class Timer(object):  
    def start(self):  
        if hasattr(self, 'interval'):  
            del self.interval  
        self.start_time = time.time()  
  
    def stop(self):  
        if hasattr(self, 'start_time'):  
            self.interval = time.time() - self.start_time  
            del self.start_time # Force timer reinit


def mat_links(n):
    '''A matrix that gives the ending node (lower gen) and starting node (higher gen) of a dichotomous and 
    symmetric tree of n generations.

    General form of the Matrix : (for any, non dichotomous or non symmetric system)
    Each line's index is the index of the link, and each line gives the indexes of the two related nodes
    '''

    M = [['atm',0],[0,1]]
    for i in range(2,2**n):
        if i%2 == 0 :
            M.append([i//2,i])
        else : 
            M.append([(i-1)//2,i])
    return M

def mat_nodes(n):
    '''A matrix that gives the links connected to a node in a dichotomous and symmetric tree for n gen

    General form of the Matrix : (for any non dich. or non sym. system)
    Each line's index is the index of the node. Gives the list of the index of the connected links. 
    '''

    M = [[0,1]]
    for i in range(1,2**(n-1)):
        M.append([i,2*i,2*i+1])
    return M

##################################################################################


def gen_count(mat_link, mat_node):
    '''builds a vector where the index is the same as the links and the value is the generation of the link
    i.e. : the i-th value is the generation of the link n°i
    '''
    N = len(mat_link)
    gen = [-1]+[0 for k in range(N-1)]
    for i in range(2,N): #the first two links are the one depicting the trachea and the first, only branch, we set them at gen = -1 and gen = 0
        j = i
        c = 0
        while j>1: #we stop if we reach the gen 0, i.e. the link n° 1
            a = mat_link[j][0] #a = index of node of lower gen than j
            j = min(mat_node[a]) #we refresh j by taking the index of the link that leads to j (of lower gen)
            c+=1 #we count how many gen we go up
            if c >= 40:
                break
        gen[i] = c

    return(gen)


def D_mat_gen(mat_link,mat_node,random='stable',obst=[0,1]):
    '''builds a vector where the index is the same as the links and the value is the max diameter of the link
    i.e. :  the i-th value is the max diameter of the link n°i
    obstruction : multiplies all the diameters after the obstruction[0]e gen by a ration = to obstruction[1]

    '''

    obstruction = obst

    gen = gen_count(mat_link,mat_node)
    N = len(mat_link)
    if random == 'stable':
        R=[0.2452740046857066, 0.734726775563336, 0.41342063829833553, 0.5703751018912475, 0.04323839539072849, 0.885713515337713, 0.14470300973386685, 0.6899784361118035, 0.23462203809390525, 0.43004211289484306, 0.8824486755139638, 0.6256580877169649, 0.3850590729389568, 0.5313930680099012, 0.1296900885254032, 0.9366754312976339, 0.7714325749980561, 0.07887801430093566, 0.15340374102565046, 0.8928998508933595, 0.6236694647825638, 0.24522766576122146, 0.6341104200570363, 0.4558616997084487, 0.33561346909154777, 0.7824880588236197, 0.5844458202647997, 0.7424865649097425, 0.8306476733279718, 0.11317873358575159, 0.293536541194662, 0.007307180798175494, 0.16702865046739024, 0.06093180331674086, 0.7991565171171517, 0.7229132750339871, 0.11523166399189422, 0.37164900611979046, 0.7970930288932768, 0.9005868443401105, 0.7258247483375377, 0.9113744547915545, 0.7044901896989457, 0.028370357049827932, 0.3774493936850061, 0.9800156177035437, 0.0022444050280444605, 0.6901816390916022, 0.9173055421996467, 0.3061466968282166, 0.3703022514933364, 0.8525920915755885, 0.9400017122339704, 0.35834582827927997, 0.8008257997239004, 0.2021464915735881, 0.3455464368112695, 9.842827463080184e-07, 0.15670814680767164, 0.5192069027744195, 0.11788202474028264, 0.6400779475080236, 0.0739102704172292, 0.5178573931836515, 0.7900981292209144, 0.7236544409305821, 0.544702248033138, 0.7859034067929752, 0.4480852226610008, 0.046592394361557266, 0.38506287085753, 0.2217682232613396, 0.1069795118396194, 0.40371943773052155, 0.4711538508463068, 0.9038339292510462, 0.7631445848753485, 0.3165023241202596, 0.6000414631442229, 0.45966036009106104, 0.21867466477827158, 0.8481380779786948, 0.5098516863895444, 0.6936290517077406, 0.6913960506774058, 0.6714355216779336, 0.4232966601009943, 0.718079233852278, 0.3726994082814672, 0.327636511843704, 0.9967701562004633, 0.8638870836597922, 0.49158226978943365, 0.9858131139505033, 0.27651574705290904, 0.4449408461242035, 0.78705178510298, 0.4538931215923284, 0.08523504673310678, 0.15476168714497474, 0.4784784623680334, 0.16701143176741617, 0.0761947363433948, 0.7458917613181453, 0.6807277336922465, 0.2442425527335873, 0.1262013534592421, 0.795776096859123, 0.05731625065741963, 0.13155898122370935, 0.3507688783979428, 0.11203161945341422, 0.5063865817705923, 0.46552115540106687, 0.2614093188897403, 0.9763962482157641, 0.7338464290767013, 0.22314842504932175, 0.40272378849039625, 0.4814018836114473, 0.24588520007058134, 0.27313627509093785, 0.39060130506077206, 0.9923484500480817, 0.9485202902316159, 0.8825380042279805, 0.19200997288871902, 0.39779918641673184, 0.23249186093804508, 0.9967151007516651, 0.7080691920731761, 0.5714847135257572, 0.5985562353806222, 0.5957577889715526, 0.6795900403875069, 0.1253096585845762, 0.31098046185449746, 0.7803873546818072, 0.5378923499690064, 0.7086274765084304, 0.627093561390319, 0.7525587642701433, 0.24030184766565688, 0.8386128327090069, 0.48541333340215775, 0.08355832435503263, 0.33423037971266634, 0.5400980188130226, 0.7500540194533742, 0.28264314216631314, 0.5699735917479178, 0.899791486669126, 0.5719124193491283, 0.2835403932700342, 0.794134370733548, 0.9622310614512225, 0.7771212445260912, 0.6514070118192132, 0.23893277086922726, 0.3153349839144306, 0.6759794422778242, 0.35074999836473897, 0.9820147895388032, 0.08117645067172352, 0.7743042526499903, 0.9694427107354854, 0.10849778826972356, 0.47658308437916463, 0.6253992037974497, 0.010940869335910763, 0.38075150423928095, 0.39564292137083257, 0.19606764122042608, 0.20834340764005643, 0.5203406466705868, 0.2516438611220968, 0.7702280526695119, 0.3326296673664263, 0.08682543975689438, 0.868632303472357, 0.6450612960816916, 0.1053139035405446, 0.5686228349516227, 0.19875749645483454, 0.740644980797003, 0.6020781182015252, 0.5704124302231017, 0.7527556406972482, 0.9782007107329913, 0.8677496992419672, 0.48705386014240826, 0.8057841950837511, 0.8802905868700738, 0.3731760089510565, 0.48430004852863917, 0.3146065651745765, 0.32249365464765845, 0.46204555020835525, 0.02018905099572066, 0.6749973010684986, 0.5585428694855836, 0.2259779363049066, 0.5389671401910376, 0.35006988727107247, 0.2462314065389024, 0.5803994030831399, 0.18072466740606374, 0.44640292263141657, 
    0.9721873702485186, 0.24450115207583234, 0.7312292452938218, 0.1292715606113568, 0.19578444138867945, 0.18466657240786133, 0.2942531787110557, 0.04383757056959858, 0.352285194703159, 0.413336008275193, 0.4081470586572029, 0.4378191309183541, 0.49080604356248236, 0.3671928201548351, 0.20324690539922619, 0.9833303735578814, 0.7417093597295276, 0.532454376549056, 0.06636410024392703, 0.5181587355679305, 0.5340892918373598, 0.9179169855260934, 0.3803800038260372, 0.5011254956171604, 0.9467589793550278, 0.31967253716025357, 0.38502689840077586, 0.7629432101214513, 0.15507716550662753, 0.6452204525505257, 0.39314892555668746, 0.5448136457226027, 0.2503616947656502, 0.7012696167166007, 0.7657061327905608, 0.49226996740013307, 0.02233254566730114, 0.7414974939237513, 0.1477641908850842, 0.18721844136913013, 0.3692738555509444, 0.24589797394863933, 0.21136935074530394, 0.2935409371137603, 0.12976400627667062, 0.4723116905235768, 0.9698260931757472, 0.13404772015440347, 0.13703583065327163, 0.6748766454705827, 0.29259360319352334, 0.055992568929721154, 0.4199656710959111, 0.22673168095292218, 0.5160181501582014, 0.5132659989175525, 0.9555029253060816, 0.23608261388330365, 0.8474017756065109, 0.3714044586140576, 0.6196066878412667, 0.9988450180788385, 0.42233532398649787, 0.6137013393168491, 0.026688197712687933, 0.48813735441230854, 0.3635110021659348, 0.37375363541724116, 0.43058640863852415, 
    0.326434223920654, 0.45233205591506365, 0.36017141012155407, 0.1941023178793635, 0.5606810319902183, 0.46301425243012895, 0.17768114192729012, 0.4810431236302143, 0.896630094058308, 0.5945323395604136, 0.2985881772791792, 0.09365017487364535, 0.01951040835646123, 0.9979625689267684, 0.8212140568719755, 0.9734467078805716, 0.21428217714459863, 0.12690915147249038, 0.8426192977679638, 0.1603244563238766, 0.569925084942111, 0.47455783664379514, 0.08131277327499298, 0.16178748319704817, 0.0501227892660282, 0.08498456263234022, 0.34665162477994826, 0.5216933673123458, 0.45679055748628405, 0.7757014271256762, 0.3008934791726088, 0.6411838340096494, 0.2864202704355573, 0.3611616192033261, 0.9457971699988043, 0.33387166366847154, 0.2577692909830186, 0.7918516853573466, 0.46474754921693373, 0.9569286866463008, 0.3395763498014732, 0.443238408830936, 0.5833777826407719, 0.8235107591578856, 0.3570833405769438, 0.1678013405894755, 0.7996432783584018, 0.6722870021479213, 0.4807091331297768, 0.802389296782724, 0.9441550670717234, 0.25389015565250916, 0.44102397712743635, 0.007893057623944988, 0.641182748015381, 0.13174946630552908, 0.35380342261380804, 0.6056988382554668, 0.04123535397815703, 0.21124534054336852, 0.4678095121364988, 0.043480219174619195, 0.10706465253889719, 0.9941209429901111, 0.6440997012942706, 0.5234636894380252, 0.9518187071903337, 0.01366474320693345, 0.42854180044572243, 0.2807050615127048, 0.41479313626525105, 0.23487718791431988, 0.2921760491978781, 0.5463056621872496, 0.9619158397256908, 0.08764953552417742, 0.43878285943292716, 0.82929383605779, 0.5363464376912244, 0.995862423725737, 0.2673700870171992, 0.3731480079276205, 0.6105925216668119, 0.2827684995235451, 0.04160297642931887, 0.8560052481132189, 0.7809188749674627, 0.020265604096987966, 0.3317858068867853, 0.8842720461945102, 0.22400957208013705, 0.9742079789861152, 0.01833421000662916, 0.9287958324958225, 0.9885372652273874, 0.3637727306911369, 0.4150407845823041, 0.8586704372364823, 0.9555029656555694, 0.28282566147869503, 0.8360178217454081, 0.023246609709398736, 0.10359448146648864, 0.3024207531779035, 0.04516973365446009, 0.9358274206239361, 0.1851584715132587, 0.2743310447343559, 0.17147994030862534, 0.8252473045826476, 0.057044971222482754, 0.31131137783975626, 0.9063427752887052, 0.8658866886855682, 0.5046959202255853, 0.15807954584957562, 0.29276945728108783, 0.5274955420154402, 0.6109779679683816, 0.5235079589329872, 0.2546236764850448, 0.19275384349214764, 0.9180062980341995, 0.5661286555160271, 0.43545652970354165, 0.8962582742906512, 0.31665074513605995, 0.52349096296907, 0.021464753978265416, 0.6034615185390345, 0.8825121622689618, 0.34879925681977286, 0.9088401785243507, 0.5182279827940806, 0.12686857521879935, 0.6298313944983404, 0.2324129988600092, 0.5114240270265076, 0.4025771067636248, 0.5255184153861632, 0.834053303074637, 0.98017256849308, 0.3568521457261504, 0.47508637113594454, 0.5205783085462853, 0.21876969158467674, 0.46785223314076585, 0.11729023581603892, 0.9917296401146868, 0.9679469376853007, 0.9138283694116311, 0.2865062849418576, 0.040836066709535546, 0.6129279354791294, 0.5996753239365943, 0.21417342446985765, 0.31185116801061363, 0.7085657300538223, 0.24471515840726143, 0.5936376543432245, 0.5849864268993521, 0.5972072751567856, 0.18787058604309725, 0.6093348368377827, 0.09848743559265971, 0.22374059877704766, 0.4541293975843713, 0.1739204322381217, 0.9001396104159812, 0.5795262084373394, 0.219204323975132, 0.27401348433455375, 0.18626999181634551, 0.10682159012510617, 0.639284483388778, 0.5904893737736395, 0.9195183790123134, 0.8090641966827609, 0.33783761026916215, 0.34630390806148426, 0.8982317119205667, 0.39713701183207406, 0.9621344796082142, 0.7524553877328541, 0.9192539289411789, 0.5876176833474874, 0.5339998148044938, 0.07450362761560281, 
    0.3696481840544906, 0.6367874591196709, 0.9770256720273207, 0.2231874146666757, 0.08211914028517497, 0.5591229693105664, 0.521946025516408, 0.4952667035398174, 0.3482829470414115, 0.4315997310860936, 0.2967093576912183, 0.34544092281732486, 0.448082256105677, 0.2710550669391939, 0.23613234446383113, 0.7486908280058698, 0.29002829971331534, 0.8327553085290884, 0.5127683569713131, 0.9838021691635574, 
    0.8094045029482052, 0.9578866885017849, 0.3040830223092915, 0.9450197314045475, 0.40880897716434295, 0.6509414083425428, 0.13458997150637464, 0.4787091910673118, 0.6269218674056095, 0.38668779337530057, 0.08450565996482495, 0.4276494811162408, 0.6584241932077926, 0.13924912757542696, 0.4112055942091625, 0.5814073510789206, 0.05216609010474005, 0.6894061574407446, 0.9652368416412737, 0.8143834630943093, 0.24892136229114614, 0.30659121028770364, 0.3206408755504333, 0.3941826055652733, 0.08057262992277003, 0.033687633267760475, 0.6096399231955346, 0.40534927480276306, 0.15052184779674127, 0.2325329296699059, 0.33863622461723974, 0.910858456475036, 0.9428432195637602, 0.7510151504215075, 0.18144709323570474, 0.585816156740406, 0.9415099479002923, 0.6920049082017982, 0.5346236551943624, 0.43124925026098593, 0.18631342686308383, 0.21912044449596912, 0.11252487597676852, 0.05576505135663956, 0.5346029225951088, 0.6169213358212111, 0.35091165872836605, 0.08657668172821431, 0.7357685210055995, 0.7253321271888867, 0.2053600318049269, 0.091413331751651, 0.6503078857733665, 0.04818705258058298, 0.5641266249751757, 0.3132531221922663, 0.5712470712832536, 0.05520508198506424, 0.11203892364287615, 0.2946233753724714, 0.7872249298155911, 0.5661232507793366, 0.7867889698321912, 0.2533938597077413, 0.3229968683443041, 0.9254003432336997, 0.703963409674141, 0.38701285519709405, 0.17219957080382997, 0.3290084751698812, 0.7329253616875437, 0.9050677399266702, 0.44723116508613636, 0.05159888530886225, 0.19197133078106055, 0.13890975981707165, 0.5008354776252094, 0.6883462442631998, 0.8933922978241637, 0.056513898193571, 0.6282385012750022, 0.2963317563539405, 0.446751386784519, 0.7780688750492684, 0.2601175558484241, 0.21933662012617117, 0.2443608436977498, 0.7805184353844715, 0.37428152941675696, 0.003211921879067048, 0.017956772510759778, 0.19822690172170276, 0.963698319378637, 0.547541987337036, 0.832883348269771, 0.11784819481058784, 0.40346201673725735, 0.08052244208418846, 0.06693849260783225, 0.3695119429655892, 0.8418788207694657, 0.5200342035547884, 0.8387473909304808, 0.7698761976810033, 0.30940123286826826, 0.8677418196679901, 0.08699080754440147, 0.009690962777340384, 0.9198824369166776, 0.9469167403457627, 0.9376489207834832, 0.083075606760589, 0.6253203954941654, 0.18929740771346992, 0.8511727438944375, 0.18585912305142382, 0.5841482207940749, 0.4369714116538195, 0.6137434337258155, 0.7192100109154562, 0.2323547022146062, 0.6415878282452998, 0.6966470049485843, 0.47543504631058064, 0.6125889783570043, 0.45153932983487843, 0.13412319318091848, 0.6605197428064098, 0.6978190517795159, 0.6448628645619716, 0.49187233175626444, 0.22422582126748447, 0.18788355281358515, 0.9496715982417558, 0.1337585991472663, 0.14028016172177427, 0.6577645518267355, 0.1297350839270246, 0.3531907701763798, 0.10654140602518236, 0.43335229466030056, 0.47332110028936947, 0.5808051134929652, 0.755191288810903, 0.4965331713459379, 0.6147255141762337, 0.049457247588164055, 0.5423436755159318, 0.7722764877078307, 0.12528421837694625, 0.5403718163272547, 0.5401987347348999, 0.9756781083705883, 0.9553206763288768, 0.8014621150407805, 0.38977035118729875, 0.47532668906462927, 0.7689043144977377, 0.21655067792719707, 0.031042488309706462, 0.2524786314477816, 0.9933526834473408, 0.07178834968906822, 0.8212905743585777, 0.15167719442187388, 0.02570730265700727, 0.5033962125164139, 0.7048592042151139, 0.683938350141425, 0.8863681770760873, 0.44383584924255803, 0.015379808276000162, 0.24287093434347162, 0.7338706959375685, 0.28425868889551775, 0.2739701585458303, 0.5422950838668654, 0.39062544699435053, 0.24151912020554567, 0.8274398389317204, 0.5669222619019153, 0.013055359724406967, 0.6012375712589206, 0.811040027515878, 0.8662830390993959, 0.11288384343195601, 0.12895782285219137, 0.8470188306850899, 0.9539460593167516, 0.9294881467678371, 0.14009231061730176, 0.6118811695039028, 0.22162716925541093, 0.9393481160577133, 0.4329147442675776, 0.27775911754640525, 0.7654273525232406, 0.9366278587614595, 0.9672706538575924, 0.4872656570288092, 0.9128849790564136, 0.6295470619757911, 0.5617676600494922, 0.7513881657158035, 0.08956257809272627, 0.2598286680989337, 0.2885183935898469, 0.13132622431319374, 0.0908123059747259, 0.5499715290135173, 0.6443542642904728, 0.6217107423448659, 0.9555985584314559, 0.5747713408723625, 0.6831953871748616, 0.3334202039414055, 0.058499637225438605, 0.4052486517562195, 0.45277813125865396, 0.3284287873754489, 0.20954086240848158, 0.5931546330692599, 0.7283208143480703, 0.11639424351923389, 0.7443838204305456, 0.5732274904766546, 0.23872456056701918, 0.9546827063600405, 0.2148994510020511, 0.24652278269501682, 0.9904405917544642, 0.9556094200589033, 0.22160117427120085, 0.3759773981464575, 0.018867474083480107, 0.8489405774676149, 0.43134366931588786, 0.6762703755810004, 0.16267042032937262, 0.8927445786624928, 0.7225552853833308, 0.5020922240178092, 0.4571862597604688, 0.6203239841796185, 0.04384814076168497, 0.14739706614156745, 0.5415794347201335, 0.38475743300271925, 0.13142353740102586, 0.5101338162087233, 0.31642308540244124, 0.9884422122911372, 0.8124326463708202, 0.08589822821679693, 0.35273990136806144, 0.5096772977225197, 0.9321151138740217, 0.1576538862591348, 0.06905308070312166, 0.20112655749675346, 0.5692195767339644, 0.8657813629099325, 0.7638511725149219, 0.7645547766295773, 0.7432523597686364, 0.07404572802950415, 0.2839994201793036, 0.43787447396070267, 0.8187517212683896, 0.4656566922597305, 0.6922159615930578, 0.3755645195236297, 0.8574216540059767, 0.7591164261251254, 0.5679632038532811, 0.383540858316342, 0.9112595152844575, 0.08126867810985394, 0.8195824133655658, 0.855204460973302, 0.9732067889276889, 0.5054454193113221, 0.5526183512110079, 0.9176864038835791, 0.28573805934418683, 0.6017085682641666, 0.914153396028801, 0.35228628088051883, 0.8617556856943035, 0.08946699807063763, 0.08191452988400527, 0.6786364529386549, 0.3491592371185991, 0.05698587532923549, 0.2218150874461181, 0.0647757725599638, 0.03686642321651634, 0.26211759786670685, 0.7805094094016213, 0.047994132949508383, 0.46770154233566774, 0.8593141767883757, 0.12195065918904069, 0.6160129414190584, 0.25134265034681924, 0.15451242249761787, 0.7629559440525759, 0.8537320149158242, 0.8388471968484829, 0.41834091414852537, 0.2944478756355343, 0.14232539706085767, 0.3550906804450059, 0.77438942165377, 0.6772993050515738, 0.15200023442846333, 0.04407029782312166, 0.9485109114957709, 0.28554639002014437, 0.6986856529831383, 0.12929599992791352, 0.07577279913216362, 0.703294296380718, 0.6864636091344541, 0.2335877897884837, 0.7465206415352017, 0.7122875828980842, 0.2864013498920671, 0.9240153342325809, 0.9563879200610033, 0.1969416727260157, 0.133901880415232, 0.7569252019541031, 0.8247825191688428, 0.011602525097618166, 0.20973846676949104, 0.884818745015448, 0.129822691041663, 0.0024537771196112557, 0.05319551510004672, 0.6381774321127086, 0.7256604945531726, 0.44821870955123866, 0.2981842135842847, 0.4224814205225381, 0.39442329117350183, 0.5086549510232763, 0.22569489548359944, 0.509833950808684, 0.8577708929197024, 0.7838863698947379, 0.3062595305082847, 0.03832680213344175, 0.4972580142652935, 0.24308240537040726, 0.15602862686935381, 0.8750288073480003, 0.4660568069054132, 0.5749311246351858, 0.45878866547973307, 0.18633494960803632, 0.2860279311315921, 0.08236792933080117, 0.468658810963853, 0.2160723114195462, 0.31472653808102946, 0.47803139514593984, 0.5795854549507945, 0.6565289060092967, 0.4822831778265534, 0.7889688470107846, 0.23072527819551902, 0.6899244507018732, 0.18521368628236734, 0.8997239547096122, 0.5463632188432336, 0.34647947654847067, 0.6243664802226538, 0.5524194285410363, 0.9158375187019382, 0.4999167782803179, 0.45270474363698365, 0.41106415780330996, 0.33008884255827176, 0.5649418162426819, 0.5348555241259093, 0.5312025086831449, 0.15081683607073337, 0.2613513571449716, 0.4373003833652568, 0.2965735234612088, 0.9405269749667408, 0.8611312874866188, 0.5309895800239853, 0.6053966648780771, 0.7153050857772079, 0.6465847088066046, 0.12319647030285896, 0.7189895888599189, 0.7255510199669225, 0.6189131478636057, 0.61740905039234, 0.8788777064479815, 0.7787360870524352, 0.9044836552276719, 0.9912006576390098, 0.9839855939142839, 0.6743165284719612, 0.1132663783720177, 0.6020670524221762, 0.1898415533735438, 0.12097922765037972, 0.21428511697419128, 0.07922276360579739, 0.34630964465173153, 0.546136595663429, 0.1597024119902467, 0.2727137032383742, 0.5225487776003939, 0.6881943315689206, 0.2343707888574441, 0.4013310894764228, 0.24258845172069876, 0.7254324117049225, 0.4991557126631, 0.6202026783718357, 0.2953600950334163, 0.3405275450189248, 0.04356118525344166, 0.16099127533441815, 0.19054367856437227, 0.22268811057345472, 0.6268747877156279, 0.9819000866706681, 0.29382711394134187, 0.393528334795337, 0.9720046290869783, 0.5976910296190863, 0.4375294412813924, 0.6038662044244811, 0.5598956196364056, 0.5174286698448508, 0.5007948484421582, 0.48341495546214563, 0.024367806987113494, 0.7597956199684749, 0.7297922225711104, 0.5580239434695253, 0.1429063998381449, 0.07557491956076179, 0.5479135795216039, 0.9826297908705054, 0.2790809809809881, 0.8005074492184777, 0.45148767588220506, 0.49608134612632315, 0.3984079384514443, 0.9077651992857263, 0.38242824335933256, 0.39330583297285415, 0.825560516291092, 0.9157336153905016, 0.5183247407330726, 0.022045101346844787, 0.30930524195036935, 0.5748165299996257, 0.7405596230423984, 0.22773244892150857, 0.6668631091761112, 0.08866249077140453, 0.5443081998074493, 0.202698046132325, 0.43378152211045395, 0.5406174434370725, 0.7652413380117487, 0.5877996298447689, 0.8019724528871908, 0.555642328913547, 0.6485508373012823, 0.5237956516210492, 0.32420098141438924, 0.9842618579553316, 0.7960825105426232, 0.9013174190471092, 0.8174346395654755, 0.9496069485172675, 0.338972793451513, 0.5228734070334483, 0.11335828305896134, 0.8265504353863081, 0.7562071841886981, 0.5034922097633798, 0.33736859411064124, 0.3504517804937163, 0.20334833653562168, 0.3998266219159612, 0.4180165912473772, 0.5726087016204042, 0.054939338577557506, 0.6033056815305111, 0.20449201636979686, 0.923744697125396, 0.31047376178518893, 0.35909709856669525, 0.2920450798383055, 0.07341660143939721, 0.5185547115237183, 0.3580377103178394, 0.13855405937777077, 0.3796903063792554, 0.546588633306732, 0.35185614364891127, 0.39642354219766374, 0.26429991289253607, 0.692639970750805937777077, 0.3796903063792554, 0.546588633306732, 0.35185614364891127, 0.39642354219766374, 0.26429991289253607, 0.6926399707508036]
    if random == 'random':
        R=[np.random.random_sample()for k in range(1000)]
    D_mat = [Dmax_0,Dmax_0] + [0 for k in range(N-2)]
    i=0

    for node in mat_node[1:]:
        g=gen[node[-1]]
        h_m,h_M = h_list[0][g],h_list[1][g]
        r=R[i%1000]
        if r<0.5:
            D_mat[node[1]]=D_mat[node[0]]*h_m
            D_mat[node[2]]=D_mat[node[0]]*h_M
        if r>=0.5:
            D_mat[node[1]]=D_mat[node[0]]*h_M
            D_mat[node[2]]=D_mat[node[0]]*h_m
        #print('-------\n node',node,'gen',g,'hm,hM',h_m,h_M,'\n D',D_mat)
        i+=1
    
    # for idx,D in enumerate(D_mat): #Simple COPD modeling
    #     if gen[idx]>=obstruction[0]:
    #         D_mat[idx] = D*obstruction[1]

    return D_mat

# n=8
# link,node=mat_links(n),mat_nodes(n)
# Ds=D_mat_gen(link,node)
# print(max(list(set(Ds[-2**7:]))),min(list(set(Ds[-2**7:]))))




def P_alv(t,VL_t,Phi):
    """Computes the initial pleural pression for a last-gen node (to determine Initial Conditions)
    """
    P_al = Pm*(1-np.exp(-t/tau))*((VL_t-RV)/CV)-(R*Phi)
    return P_al

def P_Pl(t,VL_t,Phi):
    '''Computes the pleural pressure, considered uniform for the lung system at time t:
    '''
    Pst = (V_max - V_min)*(1/C_0)*np.log((V_max-V_min)/(V_max-VL_t))
    return P_alv(t,VL_t,Phi) - Pst

def DMAX(g):
    h=1
    for i in range(g+1):
        h = h*h_list[0][i]
    return(Dmax_0*h)

def D(P,Dmax,g):
    '''Compliance of a branch (link)
    returns the diameters D of the branch in function of the local pressure and generation
    '''
    a_0,n_1,n_2 = Compliance_param[g][1],Compliance_param[g][3],Compliance_param[g][4]
    P_1 = (Compliance_param[g][1]*Compliance_param[g][3])/Compliance_param[g][2]
    P_2 = -((1-Compliance_param[g][1])*Compliance_param[g][4])/Compliance_param[g][2]

    if P<0:
        return Dmax*np.sqrt(a_0*((1-P/P_1)**-n_1))
    else : 
        return Dmax*np.sqrt(1-((1-a_0)*((1-P/P_2)**-n_2)))

def D4(P,Dmax,g):
    return D(P,Dmax,g)**4

# @vectorize(['float64(float64,float64,float64,int64)'], target = 'cuda')
def int_D4(Po,Pi,Dmax,g):
    '''
    Calcule l'intégrale de Pi à Po de la fonction D(P)**4 pour la génération g
    '''
    #On charge les paramètres de compliance
   
    a_0,n_1,n_2 = Compliance_param[g][1],Compliance_param[g][3],Compliance_param[g][4]
    P_1 = (Compliance_param[g][1]*Compliance_param[g][3])/Compliance_param[g][2]
    P_2 = -((1-Compliance_param[g][1])*Compliance_param[g][4])/Compliance_param[g][2]

    #On explicite l'intégrale sur les parties positives et négatives
    def neg(P):
        return (Dmax**4)*(a_0**2)*(P_1/(2*n_1-1))*((1-P/P_1)**(-2*n_1+1))

    def pos(P):
        return (Dmax**4)*( P - 2*(1-a_0)*P_2*(1/(n_2-1))*((1-P/P_2)**(-n_2+1)) + ((1-a_0)**2)*P_2*(1/(2*n_2-1))*((1-P/P_2)**(-2*n_2+1)) )

    if Po<0:
        if Pi<0:
            return neg(Po) - neg(Pi)
        if Pi>=0:
            return neg(Po) - neg(0) + pos(0) - pos(Pi)
    if Po>=0:
        if Pi>=0:
            return pos(Po) - pos(Pi)
        if Pi<0:
            return neg(0) - neg(Pi) + pos(Po) - pos(0)

def dDdP(P,Dmax,g):
    '''Returns the derivative of D on P
    '''
    a_0,n_1,n_2 = Compliance_param[g][1],Compliance_param[g][3],Compliance_param[g][4]
    P_1 = (Compliance_param[g][1]*Compliance_param[g][3])/Compliance_param[g][2]
    P_2 = -((1-Compliance_param[g][1])*Compliance_param[g][4])/Compliance_param[g][2]

    if P<0:
        return Dmax*np.sqrt(a_0)*(n_1/P_1)*((1-(P/P_1))**(-n_1-1))*(1/(2*np.sqrt((1-(P/P_1))**-n_1)))
    else : 
        return -Dmax*(1-a_0)*(n_2/P_2)*((1-(P/P_2))**(-n_2-1))*(1/(2*np.sqrt(1-(1-a_0)*((1-(P/P_2))**-n_2))))

#@vectorize(['float64(float64,float64,float64,float64,float64,float64)','int64(int64, int64,int64, int64,int64, int64)'], target='cpu')
def f(Po,Pi,Dmax,g,Q,P_plr):
    """Function to solve = 0 for each node to find the local Pi, Po and Q of the link between
    """
    L = Dmax*L_list[g]
    Re = 4*rho*Q/(eta*np.pi*(D(Po-P_plr,Dmax,g)+D(Pi-P_plr,Dmax,g))/2)
    return np.array( int_D4(Po-P_plr,Pi-P_plr,Dmax,g)-32*((rho*Q*(1/np.pi))**2)*np.log(D(Po-P_plr,Dmax,g)/D(Pi-P_plr,Dmax,g))+1*(128*eta*L*Q*(1/np.pi))*(1.5+0.0035*Re) )

def debug_f(Po,Pi,Dmax,g,Q,P_plr):
    """Function to solve = 0 for each node to find the local Pi, Po and Q of the link between
    """
    L = Dmax*L_list[g]
    Re = 4*rho*Q/(eta*np.pi*(D(Po-P_plr,Dmax,g)+D(Pi-P_plr,Dmax,g))/2)
    a=int_D4(Po-P_plr,Pi-P_plr,Dmax,g)
    b=-32*((rho*Q*(1/np.pi))**2)*np.log(D(Po-P_plr,Dmax,g)/D(Pi-P_plr,Dmax,g))
    c=(128*eta*L*Q*(1/np.pi))*(1.5+0.0035*Re) 
    print('int D4 :', a,'\n log funtion : ',b,'\n loss term: ',c)
    print('assert that residue is negligeable in linear case : ',(abs(a)-abs(c))/(abs(a)+abs(c)))
    return

def dfdQ(Po,Pi,Dmax,g,Q,P_plr):
    '''returns df/dQ
    '''
    L = Dmax*L_list[g]
    Re = 4*rho*Q/(eta*np.pi*(D(Po-P_plr,Dmax,g)+D(Pi-P_plr,Dmax,g))/2)
    return np.array(  -64*Q*((rho*(1/np.pi))**2)*np.log(D(Po-P_plr,Dmax,g)/D(Pi-P_plr,Dmax,g))+1*(128*eta*L*(1/np.pi))*(1.5+2*0.0035*Re) )

def dfdPo(Po,Pi,Dmax,g,Q,P_plr):
    '''returns df/dPo
    '''
    return np.array( D4(Po-P_plr,Dmax,g)-32*((rho*Q*(1/np.pi))**2)*dDdP(Po-P_plr,Dmax,g)/D(Po-P_plr,Dmax,g) )

def dfdPi(Po,Pi,Dmax,g,Q,P_plr):
    '''returns df/dPi
    '''
    return np.array( -D4(Pi-P_plr,Dmax,g)+32*((rho*Q*(1/np.pi))**2)*dDdP(Pi-P_plr,Dmax,g)/D(Pi-P_plr,Dmax,g) )


def sat_fun(x,sat):
    x=np.array(x)
    if np.linalg.norm(x)!=0: 
        return (x/np.linalg.norm(x))*np.linalg.norm(sat)*np.log(1+ (np.linalg.norm(x)/np.linalg.norm(sat)))
    else : 
        return 0

def R_lin_eq(g_in,g_max=15):
    'Compute the equivalent resistance of gmax-g_in generations of linear'
    assert g_in <= g_max, 'GENERATION NB ERROR'
    R0 = (128*eta*3*Dmax_0) / (np.pi * Dmax_0**4) #Poiseuille hydraulic resistance
    return (g_max - g_in)*(2**(g_in))*R0


def refresh_system(mat_link,mat_node,P_ini,Q_ini,t=0,DeltaP=100000,stop_crit=1e-4,epsilon=[1e-2,1e-6],it_lim=1e3,V=CV,DeltaT=0.01,grad='naive',obst=[0,1]):  
    """Computes the state of the system for 1 temporal iteration 

    P_ini, Qini = set of value for P and Q 

    epsilon : the precision we want on F=0, first digit for the kirshoff equation and second for the flow one

    it_lim : max amount of iterations

    DeltaP : Linearises the D(P) :  if DeltaP if very high, the behaviour of D(P) is asymptotical and D(P) = Dmax, dDdP(P) = 0.
    If it is set to 0, we have full non linear behavior. Lim of divergence aroud P_Pl

    V = Initial lung volume at the beginning of the iteration

    Delta_t = duration of the iteration

    """

    total_time = Timer()
    total_time.start()

    print('---\nSTART ITERATION\n---')

    mat_D = D_mat_gen(mat_link,mat_node,obst=obst)
    Phi = Q_ini[0]
    
    n = len(mat_link) #N° of nodes and intersections
    P = P_ini.copy() #will contain the pressures at time t
    Q = Q_ini.copy() #will contain the debit at time t
    gen = gen_count(mat_link,mat_node)
    N_gen = max(gen) #N° of gen


    N_f = gen.count(max(gen)) # N° of end node/link
    N_Q = len(Q)-1-N_f #Nb of debit equations 
    N_Qv = len(Q)-1 #Nb of debit variables
    N_P = len(P)-1-N_f #Nb of pressure equation NOT COUNTING THE EXTRA
    N_Pv = len(P)-1-N_f #Nb of pressure variables

    
    assert len(P) == n+1+N_f , "wrong amount of Pressures eq"
    assert len(Q) == n , "wrong amount of Debit eq"


    F=[0 for k in range(N_Qv+N_Pv)]
    dF = np.zeros((N_Qv+N_Pv,N_Qv+N_Pv))
    X = np.array( Q[1:]+P[1:len(P)-N_f] )

    P_pl0 = P_Pl(t, V, Phi) 
    if DeltaP >= 0:
        P_pl = P_pl0 - DeltaP
    if DeltaP <0:
        P_pl = P_pl0

    if DEBUG >= 1:
        print('P_pl:',P_pl+DeltaP, '\nDeltaP:',DeltaP)

    assert len(X) == N_Pv+N_Qv, "Var X len issue"
        
    
    steps = 0
    start = 1


    ########################################INITIALIZE F AND DF##############################################
    P = P[1:] #BC the index 0 is the pressure BEFORE the tracheat (above gen 0), and in the P list, index 0 = P_atm, after the trachea
    F = F[:-N_f] #We cut of the end DeltaP to append them afterward

    for i in range(N_Q):  #N of nodes equation

        node = mat_node[i+1] #No node equation to solve for the node 0 between link 0 and trachea 
        for xn in node : 
            if xn == min(node):
                F[i]+=Q[xn]
            else :
                F[i]-=Q[xn]
        
        dF[i][min(node)-1] = 1

        for j in node:
            if j != min(node):
                dF[i][j-1] = -1

    for i in range(N_Q,N_Q+N_P): # N of link equation

        if i == N_Q : #Different equation for the link of the upper trachea
        #     print(i)
        #     print(P[0])
            F[i] = P[0] - P_atm - R_ext*abs(Q[1])**r
            dF[i][0] = -r*R_ext*abs(Q[1])**(r-1)
            dF[i][N_P-1] = 1
            dF[i+1][N_P-1] = dfdPo(P[0], P[1], mat_D[0], gen[1], Q[0], P_pl )

        else :
         

            link = mat_link[i-N_Q] #CARE +1..?


            F[i] = f( P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl )
            

            dF[i][i-N_Q-1] = dfdQ( P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl )

            for xl in link :

                if gen[xl] != -1 and gen[xl] != N_gen:

                    if xl == link[0]:

                        if DEBUG == 4: ######### Debugging
                            print('xl-------------',xl)
                            print(i,N_P+xl-1)   
                            print(dF[i][N_P+xl-1],xl,'C0')

                        dF[i][N_Qv+xl]=dfdPo(P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl ) #CARE -1..?
                        

                    else : 

                        if DEBUG == 4: ######### Debugging
                            print('xl-------------',xl)
                            print(i,xl,N_P+xl-1)
                            print(dF[i][N_P+xl-1],xl,'C1')

                        dF[i][N_Qv+xl]=dfdPi(P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl ) #CARE -1..?
                
                if gen[xl] == N_gen :
                    
                    dF[i][N_P+xl-1]=dfdPi(P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]],Q[link[1]], P_pl ) #eq for the inside of the link

                    dF[N_Qv+xl][N_Qv+xl] = -1

                    dF[N_Qv+xl][xl-1] = -R_lin_eq(N_gen)

                    F.append(P[xl+N_f]-P[xl]- R_lin_eq(N_gen)*Q[xl])


        
    ##################################################################################

    if DEBUG >= 1:
        print('\n first X:',X,'\n first F: ',F,'\n first dF: ',dF)
    
    def norm_corr(F,treshold,a=epsilon[0],b=epsilon[1]): #Norme personnalisée
        R=0
        for x in F[:treshold[0]]:
            R+=a*x*x
        for x in F[treshold[0]:treshold[1]]:
            R+=b*x*x
        for x in F[treshold[1]:]:
            R+=1*x*x
        return np.sqrt(R)

    N=0

    total_calc_time = 0
    total_matrix_update_time = 0
    ##################################################################################
    ##################################################################################
    while norm_corr(F,[N_Q,N_Qv+N_Pv-N_f])>=stop_crit or start == 1:

        start = 0

        #update X with Newton Raphson scheme-------------------

       # dX = np.dot(np.linalg.inv(dF),F)
        timer_calc=Timer()
        timer_calc.start()

        dX = np.linalg.solve(dF,F)

        timer_calc.stop()
        #print(f'Duration of resolution n° {steps} execution : ', timer_calc.interval)
        total_calc_time += timer_calc.interval
        
        N+=np.linalg.norm(dX)
        if grad == 'adapt' :
            X -= dX/np.log(1+N**(1.2))
        if grad == 'naive' :
            X -= dX
        if grad == 'sat':
            dX_sat = [sat_fun(dx,0.0001)for dx in dX[:N_Qv]]+[sat_fun(dx,5)for dx in dX[N_Qv:]]
            X-= dX_sat
        steps += 1

        if DEBUG >= 0 :print('Step N° : \n',steps,'------------------------------------------------------')
        if DEBUG >= 2:
            print('  dX:',dX,'\n  dX Norm :',norm_corr(X,N_P),'\n \n  X:',X,'\n  X Norm :',norm_corr(X,N_P),'\n \n  F: ',F,'\n dF.dX:',np.dot(dF,dX),'\n  dF: ',dF)
            print('P_pleural',P_pl+DeltaP)

        #Update P and Q for next iteration-----------------------
        P = [P_atm + P_pl]+list(X[len(Q[1:]):])+[P_alv(t,V,Phi)for k in range(N_f)]
        Q = [X[0]]+list(X[:len(Q[1:])])
        Q = [q for q in Q] #TO CORRECT HIGHER Q DUE TO LOW GEN 0.002?

        P=P[1:]
        F = F[:-N_f]
        #Update F and dF

        matrix_update_time = Timer()
        matrix_update_time.start()

        for i in range(N_Q):  #N of nodes equation

            node = mat_node[i+1] #No node equation to solve for the node 0 between link 0 and trachea 
            for xn in node : 
                if xn == min(node):
                    F[i]+=Q[xn]
                else :
                    F[i]-=Q[xn]
            
            dF[i][min(node)-1] = 1

            for j in node:
                if j != min(node):
                    dF[i][j-1] = -1


        for i in range(N_Q,N_Q+N_P): # N of link equation

            if i == N_Q : #Different equation for the link of the upper trachea
                #     print(i)
                #     print(P[0])
                F[i] = P[0] - P_atm - R_ext*(abs(Q[1])**r)
                # print('CORRECT',Q[1])
                dF[i][0] = -r*R_ext*abs(Q[1])**(r-1)
                dF[i][N_P-1] = 1
                dF[i+1][N_P-1] = dfdPo(P[0], P[1], mat_D[0], gen[1], Q[0], P_pl )

            else :
         

                link = mat_link[i-N_Q] #CARE +1..?


                F[i] = f( P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl )

                if steps%3!=0:
                    dF[i][i-N_Q-1] = dfdQ( P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl )

                for xl in link :

                    if gen[xl] != -1 and gen[xl] != N_gen:

                        if xl == link[0]:

                            if DEBUG == 4: ######### Debugging
                                print('xl-------------',xl)
                                print(i,N_P+xl-1)   
                                print(dF[i][N_P+xl-1],xl,'C0')
                            
                            if steps%3!=0:
                                dF[i][N_Qv+xl]=dfdPo(P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl ) #CARE -1..?
                            

                        else : 

                            if DEBUG == 4: ######### Debugging
                                print('xl-------------',xl)
                                print(i,xl,N_P+xl-1)
                                print(dF[i][N_P+xl-1],xl,'C1')

                            if steps%3!=0:
                                dF[i][N_Qv+xl]=dfdPi(P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl ) #CARE -1..?
                    
                    if gen[xl] == N_gen :
                        
                        dF[i][N_P+xl-1]=dfdPi(P[link[0]], P[link[1]], mat_D[link[1]], gen[link[1]], Q[link[1]], P_pl ) #eq for the inside of the link

                        dF[N_Qv+xl][N_Qv+xl] = -1

                        dF[N_Qv+xl][xl-1] = -R_lin_eq(N_gen)

                        F.append(P[xl+N_f]-P[xl]- R_lin_eq(N_gen)*Q[xl])
                        #print('DEBUG----',P[xl+N_f],P[xl],R_lin_eq(N_gen),Q[xl],'----')
                
                if DeltaP < 0: ##
                    P_pl = P_pl0

        matrix_update_time.stop()
        total_matrix_update_time+=matrix_update_time.interval

        if DEBUG == 3:
            if steps%10 == 0 or steps == 1:
                print('dF-1:',np.linalg.inv(dF))

        if DEBUG >= 0 :print('\n-----------------------------------------------------\n')


        if steps >= it_lim:
            break
    
    if DEBUG >= 1:
        print(' last dX:',dX,'\n last X:',X,'\n last F(X): ',F,'\n last dF(X): ',dF)
        #print('dX.dF:',np.dot(dX,dF))

    print('Number of total steps : \n',steps)
    print('Pleural Pressure : \n',P_pl)
    print('---\nEND ITERATION\n---')

    total_time.stop()
    print('TIMINGS :')
    print('total exec time:',total_time.interval)
    print('time spent on resolution:',total_calc_time)
    print('total time spent updating matrix:',total_matrix_update_time)
    print('---')

    return X,[P_atm]+P,Q,P_pl,Q[0]*DeltaT

    
def expiration(links,nodes,t0=0.001,DeltaT=0.1,DeltaP=100000,V_ini=CV,grad='naive',stop_crit=1e-4,obst=[0,1]):

    t=t0
    V=V_ini
    c=0
    dV = 1
    T_list = [t]
    D_mat = D_mat_gen(links,nodes)

    gen = gen_count(links,nodes)
    gen_unique = [k for k in range(max(gen)+1)]
    id_gen = [gen.index(k) for k in gen_unique]
    P_over_time = [[] for k in gen_unique]
    D_over_time = [[] for k in gen_unique]
    Q_over_time = [[] for k in gen_unique]


    NL=len(links)
    N_f = gen.count(max(gen))
    P=[P_atm for k in range(NL+1)]+[P_alv(t,V_ini,0)for k in range(N_f)] #At t = 0, we consider the lungs full, with no flow thus phi = 0 also
    Q=[0 for k in range(NL)]

    Debits=[]
    Volumes=[]
    lung_vol=[]

    print('EXPIRATION MODELISATION START','\nInitial Lung Volume:',V_ini,'\nMin Lung Volume:',V_min,'\nDelta P:',DeltaP)

    while V >= V_min and dV > 0.000001:

        dt = DeltaT
        c+=1
        #dt_r_count =0
        iter = refresh_system(links,nodes,P,Q,t,it_lim=1000,DeltaP=DeltaP,stop_crit=stop_crit,V=V,DeltaT=dt,grad=grad,obst=obst)
        
        # while iter[-2] == 'it_lim_reached' and dt_r_count <2:

        #     dt = dt/10
        #     iter = refresh_system(links,nodes,P,Q,t,it_lim=1000,DeltaP=DeltaP,stop_crit=stop_crit,V=V,DeltaT=dt,grad=grad,obst=obst)
        #     dt_r_count+=1
            

        t = t + dt
        T_list.append(t)

        if CHECK >= 2 : 
            print("Delta_t :",dt)

        dV = iter[-1] #volume expired during DeltaT
    
        if CHECK>=1:
            print('------------------------------------------------------','\n iteration n°',c,'\n time:',t,'\n Initial Pressure :',P,'\n New Pressure :',iter[1],'\n Initial Debit :',Q,'\n New Debit :',iter[2],'\n Volume before step',V ,'\n Expired volume during iteration:', dV)
        if dV <= 0 :
            print('ERROR : dV negative :', dV)
            break

        for i,idx in enumerate(id_gen):
            P_over_time[i].append(iter[1][idx]-iter[3])
            D_over_time[i].append(D(iter[1][idx]-iter[3],D_mat[idx],i)/D_mat[idx])
            Q_over_time[i].append(iter[2][idx])
            # print(f'P added for gen{i}' , iter[1][idx])
            # print(f'D added for gen{i}' , D(iter[1][idx],i))

        V-=dV #Volume remaining in lungs
        print(' Volume after step :',V)
        Expired_Volume = V_ini-V #Volume expired (total)

        lung_vol.append(V) #Lung volume at time t
        Debits.append(iter[2][0]) #Debit during the last iteration
        Volumes.append(Expired_Volume) #Total expired volume at time t

        P_end=P_alv(t,V,iter[2][0])
        alpha=P_end/iter[1][-1]
        P=[alpha*p for p in iter[1]]
        Q=iter[2]

        if c>=5000:
            break
        
    print('time to empty lungs :',t)

    return Debits, Volumes, lung_vol, P_over_time, D_over_time, T_list, Q_over_time



#####################################################################################
#########################################TEST########################################
#####################################################################################

DEBUG = -1
CHECK = -1
    
#NOTES : On observe une divergence des solution pour le D non linéarisé. La divergence a lieu lorsque DeltaP, le delta de linearisation, s'approche (a 10Pa près) de P_pleural

#testing for low n in a symetric tree : #############################################
#####################################################################################

# Delta_t = 0.1

# n=8
# links, nodes = mat_links(n), mat_nodes(n)

# NL=len(links)

# gen = gen_count(links,nodes)
# N_gen = max(gen) 
# N_f = gen.count(max(gen))

# P=[P_atm for k in range(NL+1)]+[P_alv(Delta_t,CV,0)for k in range(N_f)] #At t = 0, we consider the lungs full, with no flow thus phi = 0 also

# Q=[0 for k in range(NL)]

# print('links:',links,'\nnodes:',nodes)
# print('links generations:',gen)
# print('initial Pressure:',P,'\ninitial Debit:',Q)

# Rez = refresh_system(links,nodes,P,Q,t=Delta_t,DeltaP=0,it_lim=1000,grad='adapt')
# # print('New X---------------')
# # print(Rez[0])
# # print('\n individual values :', list(set(Rez[0])),'\n')
# # print('New P---------------')
# # print(Rez[1])
# print('\n Individual P values :', list(set(Rez[1])),'\n')
# # print('New Q---------------')
# # print(Rez[2])
# print('\n individual Q values :', list(set(Rez[2])),'\n')


# print((Rez[1][-1]-Rez[1][-17])/Rez[2][-1])
# print((128*eta*3*Dmax_0) / (np.pi * Dmax_0**4))


#testing for low n and an asymetric tree : ##########################################
#####################################################################################

# Delta_t = 0.02
# n=5
# # A la main
# links = [['atm',0],[0,1],[1,2],[1,3],[2,4],[3,5],[3,6],[4,7],[4,8],[5,9],[6,10]]
# nodes = [[0,1],[1,2,3],[2,4],[3,5,6],[4,7,8],[5,9],[6,10]]
# NL=len(links)

# gen = gen_count(links,nodes)
# N_gen = max(gen) 
# N_f = gen.count(max(gen))

# P=[P_atm for k in range(NL+1-N_f)]+[P_alv(Delta_t,CV,0)for k in range(N_f)] #At t = 0, we consider the lungs full, with no flow thus phi = 0 also

# Q=[0 for k in range(NL)]



# Rez = refresh_system(links, nodes,P,Q,Delta_t)
# print('New X---------------')
# print(Rez[0])
# print('New P---------------')
# print(Rez[1])
# print('New Q---------------')
# print(Rez[2])


# print('------------------------------')

# print(links, nodes)
# print (gen)
# print(P,Q)

#####################################################################################
################################     PLOT    ########################################
#####################################################################################

import matplotlib.pyplot as plt

#####################################################################################
###############################DIVERSE VARIABLES#####################################
#####################################################################################


# timer = Timer()
# timer.start()

# ##PARAMS##
# V_ini = 7e-3
# eps=1e-6
# delta_t = 0.02
# t0 = 0.001
# Delta_P = 0
# n=8 
# ##########

# #Simulate symetric tree
# links, nodes = mat_links(n), mat_nodes(n)
# #Simulate expiration for the tree
# Y,X,Z,PoT,DoT,T,QoT = expiration(links,nodes,t0=t0,DeltaT=delta_t,V_ini=V_ini,DeltaP=Delta_P,grad='adapt',stop_crit=eps,obst=[0,1]) 

# times = T[:len(Y)]
# #We put everything in liters
# Debit = [0]+[y*1000 for y in Y]
# LungVol = [V_ini*1000]+[z*1000 for z in Z]
# ExpVol = [0] + [x*1000 for x in X]


# fig = plt.figure(figsize =(14, 9))


# ax = fig.add_subplot(2,3,1) #SPIROGRAPHY
# ax.plot(LungVol,Debit)
# ax.invert_xaxis()
# ax.set_title(f'Spirography Simulation of Forced Expiration\n stopping criteria = {eps}')
# ax.set_xlabel('Volume (L)')
# ax.set_ylabel('Debit (L/s)')
# m=min(Debit)-0.5
# M=max(Debit)+0.5
# ax.set_xlim(10,1)
# ax.set_ylim(m,M)

# ax = fig.add_subplot(2,3,2) #PRESSURE FOR EACH GEN
# #---
# mi=0
# Mi=0
# for j in PoT:
#     m = min(j[:-10])
#     M = max(j[:-10])
#     if m<=mi:
#         mi=m
#     if M >= Mi:
#         Mi=M
# #---
# for j,P_list in enumerate(PoT):
#     ax.plot(times,P_list,label =f'gen {j}')
# ax.set_title('Pressure over time \nfor the different generations')
# ax.set_xlabel('Time (s)')
# ax.set_ylabel('Pressure (Pa)')
# ax.set_ylim(mi-100,Mi+100)


# plt.legend()

# ax = fig.add_subplot(2,3,3) #DIAMETER FOR EACH GEN
# for j,D_list in enumerate(DoT):
#     ax.plot(times,D_list,label =f'gen {j}')
# ax.set_title('D/Dmax over time \nfor the different generations')
# ax.set_xlabel('Time (s)')
# ax.set_ylabel('D/Dmax')

# plt.legend()

# ax = fig.add_subplot(2,3,6) #Pleural pressure over time
# P_pl_list = [P_Pl(times[k],Z[k],Y[k]) for k in range(len(times))]
# ax.plot(times,P_pl_list,label = 'Pleural pressure')
# ax.set_title('Pleural pressure over time')
# ax.set_xlabel('Time (s)')
# ax.set_ylabel('P_pl(Pa)')

# plt.legend()

# ax = fig.add_subplot(2,3,4) #Debit over time
# ax.plot(times,Debit[:-1],label = 'Debit')
# ax.set_title('Debit over time')
# ax.set_xlabel('Time (s)')
# ax.set_ylabel('Debit (L.s-1)')

# plt.legend()

# # ax = fig.add_subplot(2,3,5) #Alveolar pressure over time
# # P_alv_list = [P_alv(times[k],Z[k],Y[k]) for k in range(len(times))]
# # ax.plot(times,P_alv_list,label = 'Alveolar pressure')
# # ax.set_title('Alveolar pressure over time')
# # ax.set_xlabel('Time (s)')
# # ax.set_ylabel('P_al(Pa)')

# # plt.legend()

# # ax = fig.add_subplot(2,3,5) #Pulmonar Volume over time
# # ax.plot(times,LungVol[:-1],label = 'Lung Volume')
# # ax.set_title('Lung Volume over time')
# # ax.set_xlabel('Time (s)')
# # ax.set_ylabel('Lung Volume (L)')


# # plt.legend()

# ax = fig.add_subplot(2,3,5) #Expired Volume over time
# ax.plot(times,ExpVol[:-1],label = 'Expired Volume')
# ax.set_title('Expired Volume over time')
# ax.set_xlabel('Time (s)')
# ax.set_ylabel('Expired Volume (L)')

# plt.legend()


# # ax = fig.add_subplot(2,3,6) #Total Resistance (Palv/Q) pressure over time
# # P_alv_list = [P_alv(times[k],Z[k],Y[k])/Y[k] for k in range(len(times))]
# # ax.plot(times,P_alv_list,label = 'Alvelolar pressure / Debit')
# # ax.set_title('Alveolar pressure / Debit over time _n (= total Resistance)')
# # ax.set_xlabel('Time (s)')
# # ax.set_ylabel('Total R(Pa.s/m-3)')

# # plt.legend()



# timer.stop()

# plt.subplots_adjust(wspace=0.40, hspace=0.20)

# plt.show()

# print('total expiration computing time: ', timer.interval)





####################################################################################
###################### NULL TRANSMURAL PRESSURE POINT###############################

# gen_null,x = None,None
# X_list = []
# T_list = []

# for i in range(len(times)):
#     for k in range(len(PoT)-1):
#         if PoT[k][i]*PoT[k+1][i] < 0: #We spot in which gen is the null transmulral pressure point
            
#             gen_null = k

#             Re = 4*rho*QoT[k][i]/(eta*np.pi*(D(PoT[k][i],k)+D(0,k))/2)

#             L = DMAX(k)*3

#             x = ( - int_D4(PoT[k][i],0,k) + 32*(rho**2)*((QoT[k][i]/np.pi)**2)*np.log(D(PoT[k][i],k)/D(0,k)) ) * np.pi * 1/( 128*eta*QoT[k][i]*( 1.5 + 0.0035*Re ) )
            
#             if x > L :
#                 print('\nERROR : X TOO HIGH = ',x,'\n L = ',L,'\n Pressure "out" of branch :', PoT[k][i],'\n Pressure "in" of branch :', PoT[k+1][i])
#                 Re = 4*rho*QoT[k+1][i]/(eta*np.pi*(D(PoT[k+1][i],k+1)+D(PoT[k+2][i],k+1))/2)
#                 print('x result in next branch ? x would be :',( - int_D4(PoT[k+1][i],0,k+1) + 32*rho*((QoT[k+1][i]/np.pi)**2)*np.log(D(PoT[k+1][i],k+1)/D(0,k+1)) ) * np.pi * 1/( 128*eta*QoT[k+1][i]*( 1.5 + 0.0035*Re ) ) )
                
#             X_list.append(k+(x/L))

#             T_list.append(times[i])

# fig = plt.figure(figsize =(9, 9))
# ax = fig.add_subplot(1,1,1)

# ax.scatter(T_list,X_list,c='r',marker ='x',linewidths=1.0)
# ax.set_xlabel('Time (s)')
# ax.set_ylabel('Transmural pressure point position')
# ax.set_title('Transmural pressure point \n(position x = gen + relative abscissa in gen)')
# plt.show()





#####to mesure the resistance########################################################
# L = [2*k for k in range(15)]

# a = [(PoT[3][l]-PoT[4][l])/Y[l] for l in L]
# b = [(PoT[2][l]-PoT[3][l])/Y[l] for l in L]
# c = [(PoT[1][l]-PoT[2][l])/Y[l] for l in L]

# print('Linear res mesured at \n gen 3-4',a,'\n gen 2-3',b,'\n gen 1-2',c)



#####################################################################################
#################################COMPARE INDIVIDUALS#################################
#####################################################################################

##PARAMS##
eps=1e-6
delta_t = 0.01
t0 = 0.001
Delta_P = 0
n=8
# obstruction_ratios=[0.95,0.9]
# gen_begin_obstruction = 2
# obst_list = list(zip([gen_begin_obstruction for k in range(len(obstruction_ratios))],obstruction_ratios))
##########

#Simulate symetric tree
links, nodes = mat_links(n), mat_nodes(n)

import matplotlib.pyplot as plt
fig = plt.figure(figsize =(14, 9))
ax = fig.add_subplot(1,2,1) 
ax2 =  fig.add_subplot(1,2,2) 


# #Simulate expiration for the sane ----------------------
V_ini=7e-3
Y,X,Z,PoT,DoT,T,QoT = expiration(links,nodes,t0=t0,DeltaT=delta_t,V_ini=V_ini,DeltaP=Delta_P,grad='adapt',stop_crit=eps)

times = T[:len(Y)]
#We put everything in liters
Debit = [0]+[y*1000 for y in Y]
LungVol = [V_ini*1000]+[z*1000 for z in Z]
ExpVol = [0] + [x*1000 for x in X]
LungVol,ExpVol,Debit = LungVol[:len(Y)],ExpVol[:len(Y)],Debit[:len(Y)]
P_alv_list = [P_alv(times[k],Z[k],Y[k])/Y[k] for k in range(len(times))]

ax2.plot(times,P_alv_list,label ='SANE INDIVIDUAL')

ax.plot(LungVol,Debit,label='SANE INDIVIDUAL')#SPIROGRAPHY

plt.legend()

# #--------------------------------COPD
# for obstruction in obst_list:
    
#     obstruction = list(obstruction)

#     Y,X,Z,PoT,DoT,T,QoT = expiration(links,nodes,t0=t0,DeltaT=delta_t,V_ini=V_ini,DeltaP=Delta_P,grad='adapt',stop_crit=eps,obst=obstruction)

#     times = T[:len(Y)]
#     #We put everything in liters
#     Debit = [0]+[y*1000 for y in Y]
#     LungVol = [V_ini*1000]+[z*1000 for z in Z]
#     ExpVol = [0] + [x*1000 for x in X]
#     LungVol,ExpVol,Debit = LungVol[:len(Y)],ExpVol[:len(Y)],Debit[:len(Y)]

#     ax.plot(LungVol,Debit,label=f'obst ratio = {obstruction[1]} starting at gen {obstruction[0]}')#SPIROGRAPHY




SEVERITY=['mild','medium','severe']


#--------------------------------------------------------
#Simulate expiration for a severe copd tree--------------

for i,COPD_ratio in enumerate([0.15,0.5,1]):
    ####SEVERE COPD INDIVIDUAL DATA####

    # Diamètre de la trachée et dimension fractale
    Dmax_0 = 2e-2
    h_list = [[1,0.87,0.80,0.83,0.86]+[0.85 for k in range(15)],[1,0.69,0.67,0.67,0.74]+[0.67 for k in range(15)]]
    L_list = [3,3.07,1.75,1.43,1.85]+[3 for k in range(15)]

    #Résistance des tissus respiratoires (Pa.m^-3.s)
    R=0.050*1e+06
    #Résistance à l'écoulement de l'air dans les voies supérieures
    R_ext = 1.2e7   #Pa.(m^3.s^-1)^-1.68
    r = 1.68
    #Choix de la pression motrice initiale
    Pm=24000
    #Choix de la constante de temps de relaxation des muscles expiratoires
    tau=0.2

    #Severity of COPD (0 = mild, 1 = severe)
    COPD_lvl = COPD_ratio
    #Volume résiduel (volume d'air min dans les poumons)
    RV= (2.5 + 1.5*COPD_lvl)*1e-3
    #Capacité vitale (Volume d'air max dans les poumons)
    CV= (5.5-0.5*COPD_lvl)*1e-3

    # Compliance pulmonaire à P de rétraction élastique nulle:
    C_0 = (8.55+3.85*COPD_lvl)*1e-6 #m^3.Pa-1
    # Volumes pulmonaires min et max. CPT(Capacité Pulmonaire Totale  = CV+RV)
    V_max = (8.5+COPD_lvl)*1e-3 #m^3
    V_min = (2+1.5*COPD_lvl)*1e-3 #m^3

    Compliance_param  = [ [0,0.78-0.22*COPD_lvl,0.01e-2,1,10],
                        [1,0.78-0.34*COPD_lvl,0.02e-2,1,10],
                        [2,0.54-0.22*COPD_lvl,0.03e-2,1,10],
                        [3,0.38-0.18*COPD_lvl,(0.04-0.004*COPD_lvl)*1e-2,1,10],
                        [4,0.28-0.13*COPD_lvl,(0.05-0.014*COPD_lvl)*1e-2,1,10],
                        [5,0.2-0.07*COPD_lvl,(0.062-0.028*COPD_lvl)*1e-2,1,10],
                        [6,0.13-0.03*COPD_lvl,(0.07-0.04*COPD_lvl)*1e-2,1,10],
                        [7,0.10-0.03*COPD_lvl,(0.071-0.04*COPD_lvl)*1e-2,1,10],
                        [8,0.052-0.01*COPD_lvl,(0.072-0.043*COPD_lvl)*1e-2,1,10],
                        [9,0.048-0.01*COPD_lvl,(0.073-0.046*COPD_lvl)*1e-2,1,10],
                        [10,0.042-0.01*COPD_lvl,(0.074-0.05*COPD_lvl)*1e-2,1,10],
                        [11,0.038-0.01*COPD_lvl,(0.075-0.052*COPD_lvl)*1e-2,1,9],
                        [12,0.033-0.01*COPD_lvl,(0.076-0.053*COPD_lvl)*1e-2,1,8],
                        [13,0.028-0.01*COPD_lvl,(0.077-0.053*COPD_lvl)*1e-2,1,8],
                        [14,0.020-0.005*COPD_lvl,(0.078-0.053*COPD_lvl)*1e-2,1,8],
                        [15,0.015-0.005*COPD_lvl,(0.079-0.053*COPD_lvl)*1e-2,1,7] ]


    V_ini= CV+RV

    Y,X,Z,PoT,DoT,T,QoT = expiration(links,nodes,t0=t0,DeltaT=delta_t,V_ini=V_ini,DeltaP=Delta_P,grad='adapt',stop_crit=eps)
    times = T[:len(Y)]
    #We put everything in liters
    Debit = [0]+[y*1000 for y in Y]
    LungVol = [V_ini*1000]+[z*1000 for z in Z]
    ExpVol = [0] + [x*1000 for x in X]
    LungVol,ExpVol,Debit = LungVol[:len(Y)],ExpVol[:len(Y)],Debit[:len(Y)]
    P_alv_list = [P_alv(times[k],Z[k],Y[k])/Y[k] for k in range(len(times))]

    ax2.plot(times,P_alv_list,label = f'COPD severity : {SEVERITY[i]}%')
    ax.plot(LungVol,Debit,label=f'COPD severity : {SEVERITY[i]}%')

    plt.legend()


#--------------------------------------------------------
#Simulate expiration for LUNG FIBROSIS--------------

for i,fib_ratio in enumerate([0,0.5,1]):
        ### LUNG FIBROSIS DATA####

    # Diamètre de la trachée et dimension fractale
    # Diamètre de la trachée et dimension fractale
    Dmax_0 = 2e-2
    h_list = [[1,0.87,0.80,0.83,0.86]+[0.85 for k in range(15)],[1,0.69,0.67,0.67,0.74]+[0.67 for k in range(15)]]
    L_list = [3,3.07,1.75,1.43,1.85]+[3 for k in range(15)]


    #Severity of Fibrosis (0 = mild, 1 = severe)
    FIB_lvl = fib_ratio

    #Résistance des tissus respiratoires (Pa.m^-3.s)
    R=(0.1+0.1*FIB_lvl)*1e+06
    #Résistance à l'écoulement de l'air dans les voies supérieures
    R_ext = 1.2e7   #Pa.(m^3.s^-1)^-1.68
    r = 1.68
    #Choix de la pression motrice initiale
    Pm=24000
    #Choix de la constante de temps de relaxation des muscles expiratoires
    tau=0.2


    #Volume résiduel (volume d'air min dans les poumons)
    RV= (1.2 - 0.2*FIB_lvl)*1e-3
    #Capacité vitale (Volume d'air max dans les poumons)
    CV= (4.4-1.1*FIB_lvl)*1e-3

    # Compliance pulmonaire à P de rétraction élastique nulle:
    C_0 = (4.3-1.6*FIB_lvl)*1e-6 #m^3.Pa-1
    # Volumes pulmonaires min et max. CPT(Capacité Pulmonaire Totale  = CV+RV)
    V_max = (5.65-1.3*FIB_lvl)*1e-3 #m^3
    V_min = (1.19-0.19*FIB_lvl)*1e-3 #m^3

    Compliance_param  = [ [0,0.9,0.01e-2,1,10],
                        [1,0.9,0.02e-2,1,10],
                        [2,0.73+0.08*FIB_lvl,(0.04-0.01*FIB_lvl)*1e-2,1,10],
                        [3,0.57+0.12*FIB_lvl,(0.068-0.018*FIB_lvl)*1e-2,1,10],
                        [4,0.45+0.08*FIB_lvl,(0.098-0.018*FIB_lvl)*1e-2,1,10],
                        [5,0.36+0.12*FIB_lvl,(0.133-0.033*FIB_lvl)*1e-2,1,10],
                        [6,0.29+0.07*FIB_lvl,(0.149-0.03*FIB_lvl)*1e-2,1,10],
                        [7,0.23+0.08*FIB_lvl,(0.166-0.033*FIB_lvl)*1e-2,1,10],
                        [8,0.18+0.08*FIB_lvl,(0.181-0.035*FIB_lvl)*1e-2,1,10],
                        [9,0.15+0.08*FIB_lvl,(0.190-0.034*FIB_lvl)*1e-2,1,10],
                        [10,0.12+0.08*FIB_lvl,(0.2-0.034*FIB_lvl)*1e-2,1,10],
                       ]


    V_ini= CV+RV

    Y,X,Z,PoT,DoT,T,QoT = expiration(links,nodes,t0=t0,DeltaT=delta_t,V_ini=V_ini,DeltaP=Delta_P,grad='adapt',stop_crit=eps)
    times = T[:len(Y)]
    #We put everything in liters
    Debit = [0]+[y*1000 for y in Y]
    LungVol = [V_ini*1000]+[z*1000 for z in Z]
    ExpVol = [0] + [x*1000 for x in X]
    LungVol,ExpVol,Debit = LungVol[:len(Y)],ExpVol[:len(Y)],Debit[:len(Y)]
    P_alv_list = [P_alv(times[k],Z[k],Y[k])/Y[k] for k in range(len(times))]

    ax2.plot(times,P_alv_list,label = f'fibrosis severity : {SEVERITY[i]}%')
    ax.plot(LungVol,Debit,label=f'fibrosis severity : {SEVERITY[i]}%')

    plt.legend()



ax2.set_title('Alveolar pressure / Debit over time \n (= total flow Resistance)')
ax2.set_xlabel('Time (s)')
ax2.set_ylabel('Total R(Pa.s/m-3)')


ax.invert_xaxis()
ax.set_title(f'Spirography Simulation\nfor different severities of pulmonary diseases')
ax.set_xlabel('Volume (L)')
ax.set_ylabel('Debit (L/s)')
ax.set_xlim(10,0)
ax.set_ylim(-0.5,13)

plt.show()

#####################################################################################
#################plot for different epsilon on the same graph #######################
#####################################################################################

# T = [0.01*k for k in range(1,10)]+[0.1+0.02*k for k in range(200)]
# T=T2
# Y1,X1,Z1,A,B = expiration(links,nodes,T,V_ini=V_ini,DeltaP=0,grad='adapt')
# tau = 0.1
# Y2,X2,Z2,A,B = expiration(links,nodes,T,V_ini=V_ini,DeltaP=0,grad='adapt')
# tau = 0.3
# Y3,X3,Z3,A,B = expiration(links,nodes,T,V_ini=V_ini,DeltaP=0,grad='adapt')

# D1 = [0]+[y*1000 for y in Y1]
# L1 = [V_ini*1000]+[z*1000 for z in Z1]
# D2 = [0]+[y*1000 for y in Y2]
# L2 = [V_ini*1000]+[z*1000 for z in Z2]
# D3 = [0]+[y*1000 for y in Y3]
# L3 = [V_ini*1000]+[z*1000 for z in Z3]
# fig, (ax) = plt.subplots(1, 1)
# ax.plot(L2,D2,c='g',label = 'tau=0.1');plt.legend()
# ax.plot(L3,D3,c='b',label = 'tau=0.3');plt.legend()
# ax.plot(L1,D1,c='r',label = 'tau=0.2');plt.legend()
# ax.invert_xaxis()
# ax.set_title('Simulated Forced Expiration Spirography \n for tau = 0.2, 0.1 and 0.05')
# ax.set_xlabel('Volume (L)')
# ax.set_ylabel('Debit (L/s)')
# plt.show()


# # print('------------------------------')

# import matplotlib.pyplot as plt
# X = np.linspace(-1000,1000,10000)
# Y = [sat_fun(x,10)for x in X]
# plt.plot(X,Y)
# plt.show()